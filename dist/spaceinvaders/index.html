<!doctype html>
<html lang="en">
<link rel="stylesheet" href="/styles.css">
<title>briano.io</title>
<nav>
<section>
<a href="/">briano.io</a>
<span>Posted on: 24 Sep 2021</span>
</section>
</nav>
<main>
<section>
<h1 id="space-invaders">Space Invaders</h1>
<p>Space Invader game written in TypeScript with RxJS.</p>
<p><a href="https://bbriano.github.io/spaceinvaders/">Play the game</a></p>
<p><a href="spaceinvaders.ts">spaceinvaders.ts</a></p>
<h2 id="overview">Overview</h2>
<p>This section describes the major parts of <code>spaceinvaders.ts</code>.</p>
<pre><code>type State = Readonly&lt;{...}&gt;
type Input = Readonly&lt;{...}&gt;</code></pre>
<p><code>State</code> stores the entire game data. <code>Input</code> represents mouse and keyboard data. Readonly is used to ensure variables are never modified.</p>
<pre><code>function transition(state: State, input: Input): State {...}
function view(state: State): void {...}</code></pre>
<p><code>transition</code> returns the next state given some state and input. <code>view</code> draws state on the svg element.</p>
<pre><code>const mouse$ = fromEvent&lt;MouseEvent&gt;(document, &quot;mousemove&quot;).pipe(...)
const keyboard$ = fromEvent&lt;KeyboardEvent&gt;(document, &quot;keydown&quot;).pipe(...)
const input$ = merge(mouse$, keyboard$).pipe(
    bufferTime(FRAME_TIME),
    ...
)</code></pre>
<p><code>mouse$</code> and <code>keyboard$</code> are observables emmiting Mouse and Keyboard Input. <code>input$</code> merges them together and emits an <code>Input</code> object every 10ms. Each emission from <code>input$</code> represents one frame of the game.</p>
<pre><code>input$.pipe(scan(transition, INITIAL_STATE(&quot;&quot;))).subscribe(view)

                  /* starts with INITIAL_STATE */
                           [prev state] &lt;------+
                                |              |
                              State            |
                                |              |
                                v              |
+--------+                +------------+       |        +------+
| input$ | ----Input----&gt; | transition | ----State----&gt; | view |
+--------+                +------------+                +------+
                                                /* Modifies SVG Element */</code></pre>
<p>And finally this is how it all fit together with scan and subscribe. <code>scan</code> operator transforms the stream of input to a stream of states by transducing it with the state transition function described previously. And finally <code>subscribe</code> takes the <code>State</code> stream and pass it to <code>view</code> to display.</p>
<h2 id="functional-style">Functional style</h2>
<p>An effort was made to follow functional programming principles (purity and immutability). All functions except for <code>view</code> are pure. All variable including local variables are immutable.</p>
<p>Consider this snippet from the <code>transition</code> function:</p>
<pre><code>// newState = ammoRegen(...alienShoot(playerShoot(state, input), input)..., input)
const newState = [
    playerShoot,
    alienShoot,
    ...
    mmoRegen,
].reduce((s, t) =&gt; t(s, input), state)</code></pre>
<p>Each of <code>playerShoot</code>, <code>alienShoot</code> and so on are atomic functions with the same type as the <code>transition</code> function. Separating them serves no other purpose than to make the code more isolated and extensible. Here is one of the atomic function:</p>
<pre><code>// removeBullet removes out of screen bullets.
function removeBullet(state: State, _: Input): State {
    return {
        ...state,
        bullets: state.bullets.filter(b =&gt; b.pos.y &gt; 0),
    }
}</code></pre>
<p>Reading the function naturally describes the what instead of the how an action is performed (declarative over imperative).</p>
<p>This functional style gives great separation of concern. For example when debugging the game, each function can be tested independently without worrying about any other part of the codebase.</p>
<h2 id="extension-1-from-randomness-to-unpredictability">Extension 1: From Randomness to Unpredictability</h2>
<p>It is desirable to have the aliens shoot at a random interval. But random functions are not pure. This is because pure functions must always return the same value given the same input. This section discuses how a randomness-like feature was implemented in the game.</p>
<p>The solution is to use hash functions. Hash functions returns a random-looking value given any (often string) input. But they are pure and always return the same value given the same input.</p>
<p>The desired behaviour using the non-pure <code>Math.random</code> function:</p>
<pre><code>Math.random() &lt; ALIEN_SHOOT_PROB /* shoot OR no shoot */</code></pre>
<p>And here is the equivalent pure function version:</p>
<pre><code>simpleHash(JSON.stringify(state) +
    JSON.stringify(alien))/2**32 &lt; ALIEN_SHOOT_PROB</code></pre>
<p><code>simpleHash</code> is a hash function returning an integer in <code>[0..2^32)</code> based from bryc’s comment from <a href="https://gist.github.com/iperelivskiy/4110988" class="uri">https://gist.github.com/iperelivskiy/4110988</a>.</p>
<pre><code>function simpleHash(s: string): number {
    const hash = s.split(&quot;&quot;).reduce((acc, x) =&gt;
        Math.imul(acc ^ x.charCodeAt(0), 2654435761),
            0xdeadbeef,
        )
    return (hash ^ hash &gt;&gt;&gt; 16) &gt;&gt;&gt; 0
}</code></pre>
<p>The serialized <code>state</code> acts as a seed value to generate a “random” number. serialized <code>alien</code> is also passed so each call is unique on the alien. Otherwise aliens would all shoot at the same time.</p>
<p>To iterate again there is no randomness here. Just a trick of using pure hash functions which are hard to predict. The user would never know.</p>
<h2 id="extension-2-character-matching">Extension 2: Character matching</h2>
<p>This feature was added to make the game more challenging, by adding a mechanism where user shoots letter at alien with matching letters. Assign a letter to each Alien. When user press keyboard keys to shoot bullets with the specific letter. if an alien was shot with a matching letter bullet then the player gets bonus points.</p>
<p>Before this feature was added, all controls are made with the mouse. So to add this feature, a new Keyboard input type was created.</p>
<pre><code>type Input = Readonly&lt;{
    mouse?: Mouse
    keyboard?: Keyboard
}&gt;
type Keyboard = Readonly&lt;{...}&gt;</code></pre>
<p>The <code>merge</code> operator is used to combine the <code>mouse$</code> and <code>keyboard$</code> input stream.</p>
<pre><code>const input$ = merge(mouse$, keyboard$).pipe(...)</code></pre>
<p>The <code>simpleHash</code> function from last section is used to initialize each alien with a random letter. Snippet from the <code>INITIAL_STATE</code> function:</p>
<pre><code>// i and j are integer representing the alien&#39;s index
const pseudoRandom = simpleHash(seed + JSON.stringify([i, j]))
return {
    ...
    character: ABC[pseudoRandom % ABC.length] as Character,
} as Alien</code></pre>
<p>We must filter out keys not in the alphabet in <code>playerShoot</code> atomic transition function.</p>
<pre><code>const char = input.keyboard.key.toUpperCase()
// Only accept keys in ABC.
if (!ABC.includes(char)) {
    return state
}</code></pre>
<p>And here is how the new score is calculated by counting how many alien collided with bullet and accounting for matching letter (or character).</p>
<pre><code>// Calculate new score.
const score = state.aliens.reduce((scoreA, a) =&gt; {
    return state.bullets.reduce((scoreB, b) =&gt; {
        return b.shooter !== &quot;ALIEN&quot; &amp;&amp; rectangleRectangleCollide(a, b)
            ? a.character === b.character
                ? scoreB + SCORE_ALIEN_KILL_CHAR_MATCH
                : scoreB + SCORE_ALIEN_KILL
            : scoreB
        }, scoreA)
}, state.score)</code></pre>
<p>This feature proofs to be effective in making the game more challenging.</p>
<h2 id="extension-3-ammunitionammo">Extension 3: Ammunition/Ammo</h2>
<p>The following is a snippet of code for removing aliens which got shot.</p>
<pre><code>// Only keep aliens that dont collide with any bullets.
const aliens = state.aliens.filter(a =&gt;
    !state.bullets.some(b =&gt;
        b.shooter !== &quot;ALIEN&quot; &amp;&amp; rectangleRectangleCollide(a, b)
    )
)</code></pre>
<p>It is an <code>O(N_ALIEN * N_BULLET)</code> time complexity operation. So if the player keeps shooting and adding more bullets to the game, the game will eventually slow down drastically making it unplayable.</p>
<p>Previous version used rxjs’s <code>throttle</code> operator on the input stream. This solved the too many bullet issue but makes the game feel unresponsive.</p>
<p>The current version implements an Ammunition (or Ammo for short) system. So player have a finite amount of ammunition that regenerates over time.</p>
<p>The first implementation uses the rxjs <code>interval</code> operator.</p>
<pre><code>const ammoRegen$ = interval(2000).pipe(...)
const input$ = merge(mouse$, keyboard$, ammoRegen$).pipe(...)</code></pre>
<p>This solution works but <code>ammoRegen</code> seems out of place in the <code>Input</code> type.</p>
<pre><code>type Input = Readonly&lt;{
    mouse?: Mouse
    keyboard?: Keyboard
    ammoRegen?: boolean // if true, regenerate ammo
}&gt;</code></pre>
<p>So it was redesigned with an extra state variable, <code>ammoRegenTimer</code>. <code>ammoRegenTimer</code> is decremented every frame and once it reached 0, the <code>ammo</code> state is incremented the the <code>ammoRegenTimer</code> is reset.</p>
<pre><code>// ammoRegen increments ammo by AMMO_REGEN_AMOUNT but no more than AMMO_MAX.
function ammoRegen(state: State, _: Input): State {
    if (state.ammoRegenTimer &gt; 0) {
        const ammoRegenTimer = state.ammoRegenTimer - 1

        return {
            ...state,
            ammoRegenTimer,
        }
    }

    return {
        ...state,
        ammo: Math.min(AMMO_MAX, state.ammo + AMMO_REGEN_AMOUNT),
        ammoRegenTimer: AMMO_REGEN_TIMER,
    }
}</code></pre>
<p>This limits the maximum number of bullet in the state solving the main problem making the game playable and responsive.</p>
</section>
</main>
